# Chapter 2

## 2.1 基本数据类型

- 无符号类型负数会变正数(2^32 - x)

- 不要混用无符号和有符号类型

- 多行书写字符串字面值 “a”"b"=="ab"

- \转义符后面最多跟三个8进制数,例：”\1234“代表两个字符'\123'和'4'

- "\x1234"表示16位字符,char占8位，一般需要在前后指定类型

- 指定一个字多长、带不带符号可以使用U、L、LL

### 练习题2.5

**a)** 'a',  L'a', "a", L"a"

答: 

char是8位[字符](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6)类型，最多只能包含256种字符，许多外文[字符集](https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86)所含的字符数目超过256个，[char](https://baike.baidu.com/item/char/5156054)型无法表示。

wchar_t数据类型一般为16位或32位，但不同的C或[C++](https://baike.baidu.com/item/C%2B%2B/99272)库有不同的规定，如[GNU](https://baike.baidu.com/item/GNU/671972) Libc规定wchar_t为32位，总之，wchar_t所能表示的字符数远超char型。

我的G++ wchar_t是32位

L = wchar_t 

- 'a' 字符型 占 8 位 1 字节

- L‘a’ 字符型 占 32 位 4 字节

- "a" 字符串  占16位  2 字节

- L"a"宽字符串 占64位 8字节

**b)** 10, 10u, 10L, 10UL, 012, 0xC

- 10 10进制10

- 10u 无符号的10进制数10

- 10L 至少是个LONG

- 同上 只不过是无符号的

- 8进制数

- 16进制数

## 2.2 初始化

- 全局变量默认初始化

- 函数内、类的变量不会默认初始化，访问有危险

- 为了支持分离式编译，声明和定义分开，声明能多次，定义只能一次。区别：定义会分配空间。声明的方法：加extern

- C++是静态类型语言，必须事前知道变量是什么类型的

## 2.3 复合类型

- 引用即起别名

- 引用定义时就得初始化

- 引用初始值必须是个对象

- 引用类型必须匹配

- 指针是个对象，也必须指向对象，但可以不给初始值

- 指针 = 指针 两指针必须类型一致

- 指针 = 对象的地址 对象的类型和指针类型需要一致

- *号可以 从对象的地址中找到对象，即解引用

- 空指针用nullptr

- void * 只能用来存地址或指针的，可以任意类型。但内容读不到

- 要有习惯显式值nullptr

- 从右往左读能帮助识别变量到底是什么，例如： int *&r = p; 就是一个引用 r，r是一个指针的别名，这个指针叫p

- const 修饰不想改变的量，它可以编译时初始化，也可以运行时初始化

- const 只对本文件有用，如果想共享const变量，其他文件需要加extern声明，然后在定义的地方也加上extern

        例如：```const in buffSize = 512; // 输入缓冲区的大小```

编译器在编译过程中将所有用到该变量的地方替换成对应的值，这也就要求编译器必须知道变量的初始值，如果程序包含多个文件，则每个用了```const```对象的文件都必须得能访问到它的初始值才行。为支撑该用法，所有```const```只对本文件有效，其他地方想访问其初始值就得加extern

- 常量引用是指对```const```的引用

- 不能右边是```const```左边却不是

- *const代表这个指针是一个常量，它一直指向一个值，内容不管。

```c
    int errNumb = 0;
    int *const curErr = &errNumb;    // curErr 一直指向errNumb
    const double p = 3.1415926;
    const double *const pip = &p;    // pip 一直指向p p内容一直固定

    *pip = 2.72;    // 错误，pip指向的值是const的

    if(*curErr){
        errorHandler();
        *curErr = 0; // 正确
    }
```
